// ignore_for_file: avoid_print

import 'package:nations_assets/assets/tur.dart';
import 'package:nations_assets/nations_assets.dart';
import 'package:test/test.dart';

/// ! DO NOT EDIT THIS FILE UNLESS
/// ! YOU NEED UPDATE THE VALIDATION LOGIC
void main() {
  test('assetsByLanguage', () {
    expect(assetsByLanguage('ar'), equals(arAssets));
    expect(assetsByLanguage('en'), equals(enAssets));
    expect(assetsByLanguage('es'), equals(esAssets));
    expect(assetsByLanguage('fr'), equals(frAssets));
    expect(assetsByLanguage('tr'), equals(TurAssets));
    expect(assetsByLanguage('tur'), equals(TurAssets));
    expect(
      assetsByLanguage(''),
      equals({}),
      reason: 'un supported Language',
    );
  });
  test('there is nothing missing', () {
    _testIt();
    expect(true, isTrue);
  });
}

void _testIt() {
  const supportedLanguages = <String, Map<String, Object>>{
    'ar': arAssets,
    'en': enAssets,
    'es': esAssets,
    'fr': frAssets,
    'tr': TurAssets,
    'tur':TurAssets,
  };

  final allKeysList = <String>[];

  /// * for each supported language
  for (final language in supportedLanguages.keys) {
    /// * for each key in the language
    final langKeys = findKeys(
      [],
      supportedLanguages[language]!,
      language,
    );
    allKeysList.addAll(langKeys);
  }

  for (final key in allKeysList) {
    // validate the key is not empty
    // or the key is not missing
    for (final lang in supportedLanguages.keys) {
      validateAssets(
          key,
          // .split('.')..removeWhere((element) => element.isEmpty),
          supportedLanguages[lang]!,
          lang);
    }
  }
  print('all assets are valid âœ”');
}

void validateAssets(String key, Map<String, Object?> assets, String lang) {
  final value = getNested(assets, key);
  final parents = key.split('.')..removeWhere((element) => element.isEmpty);
  if (parents.isEmpty) {
    // cant use empty key
    throw Exception(
      '''
        âŒ NATIONS ASSETS VALIDATION ERROR âŒ
        ERROR ğŸ˜¢:: Cant use empty string as a key
        LANG  ğŸŒ:: $lang
         ''',
    );
  } else if (value is String) {
    if (value.isEmpty) {
      throw Exception(
        '''
        âŒ NATIONS ASSETS VALIDATION ERROR âŒ
        ERROR ğŸ˜¢:: String is empty
        KEY   ğŸ”‘:: $key
        LANG  ğŸŒ:: $lang
         ''',
      );
    }
  } else if (value == null) {
    throw Exception(
      '''
        âŒ NATIONS ASSETS VALIDATION ERROR ::
        ERROR ğŸ˜¢:: Missing key
        KEY   ğŸ”‘:: $key
        LANG  ğŸŒ:: $lang
         ''',
    );
  } else if (parents.length < 2) {
    checkType(parents, value, lang);
  } else if (value is Map<String, Object>) {
    validateAssets(key, value, lang);
  } else {
    throw 'not valid value $value';
  }
}

void checkType(List<String> key, Object? value, String lang) {
  if (value is String) {
  } else {
    throw Exception(
      '''
        âŒ NATIONS ASSETS VALIDATION ERROR ::
        ERROR ğŸ˜¢:: Invalid type ${value.runtimeType}
        KEY   ğŸ”‘:: $key
        LANG  ğŸŒ:: $lang
         ''',
    );
  }
}

List<String> findKeys(List<String> parents, Map map, String lang) {
  final keysList = <String>[];
  for (final key in map.keys) {
    if (map[key] is Map) {
      keysList.addAll(findKeys([...parents, key], map[key] as Map, lang));
    } else if (map[key] is String) {
      keysList.add(buildKeyWithParents(key, parents));
    }
  }
  return keysList;
}

/// return the key with parents as string separated by `.`
/// example :
///  ```json
///         "key1": {
///            "key2": {
///               "key3": "some value"
///           }
///      }
/// ```
///  will be => `[key1,key2,key3]`  will be `key1.key2.key3`
String buildKeyWithParents(String key, List<String> parents) {
  if (parents.isEmpty) {
    /// is not nested
    return key;
  } else {
    return parents.join('.') + '.' + key;
  }
}

Object? getNested(Map map, String key) {
  if (key.contains('.')) {
    final nestedKeys = key.split('.');
    final nestedKey = nestedKeys.first;
    if (map[nestedKey] == null) return null;
    nestedKeys.removeAt(0);
    return getNested(
      map[nestedKey],
      nestedKeys.join('.'),
    );
  } else {
    return map[key];
  }
}
